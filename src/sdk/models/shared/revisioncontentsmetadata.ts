/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  RelativeDiff,
  RelativeDiff$inboundSchema,
  RelativeDiff$Outbound,
  RelativeDiff$outboundSchema,
} from "./relativediff.js";

export const RevisionContentsMetadataType = {
  OpenapiBundle: "OPENAPI_BUNDLE",
  OpenapiOverlay: "OPENAPI_OVERLAY",
} as const;
export type RevisionContentsMetadataType = ClosedEnum<
  typeof RevisionContentsMetadataType
>;

export type RevisionContentsMetadata = {
  /**
   * Whether the OAS contains code samples.
   */
  containsCodeSamples: boolean;
  createdAt: Date;
  /**
   * The OAS description
   */
  description: string;
  /**
   * The hash of the contents
   */
  hash: string;
  /**
   * The fully qualified namespace
   */
  namespace: string;
  /**
   * The number of overlay actions in the OAS. Will be 0 if the OAS is not an overlay.
   */
  numOverlayActions: number;
  /**
   * The operation IDs contained in the OAS. Will be empty if the OAS is an overlay.
   */
  operationIds: Array<string>;
  /**
   * A relative diff between the current revision and the previous revision.
   */
  relativeDiff?: RelativeDiff | undefined;
  /**
   * The digest of the parent bundle
   */
  revisionDigest: string;
  /**
   * The tags contained in the OAS -- NOT the OCI tags. Will be empty if the OAS is an overlay.
   */
  tags: Array<string>;
  /**
   * The OAS title
   */
  title: string;
  type: RevisionContentsMetadataType;
  /**
   * The OAS version
   */
  version: string;
  /**
   * The workspace ID
   */
  workspaceId: string;
};

/** @internal */
export const RevisionContentsMetadataType$inboundSchema: z.ZodNativeEnum<
  typeof RevisionContentsMetadataType
> = z.nativeEnum(RevisionContentsMetadataType);

/** @internal */
export const RevisionContentsMetadataType$outboundSchema: z.ZodNativeEnum<
  typeof RevisionContentsMetadataType
> = RevisionContentsMetadataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RevisionContentsMetadataType$ {
  /** @deprecated use `RevisionContentsMetadataType$inboundSchema` instead. */
  export const inboundSchema = RevisionContentsMetadataType$inboundSchema;
  /** @deprecated use `RevisionContentsMetadataType$outboundSchema` instead. */
  export const outboundSchema = RevisionContentsMetadataType$outboundSchema;
}

/** @internal */
export const RevisionContentsMetadata$inboundSchema: z.ZodType<
  RevisionContentsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  contains_code_samples: z.boolean(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  description: z.string(),
  hash: z.string(),
  namespace: z.string(),
  num_overlay_actions: z.number().int(),
  operation_ids: z.array(z.string()),
  relative_diff: RelativeDiff$inboundSchema.optional(),
  revision_digest: z.string(),
  tags: z.array(z.string()),
  title: z.string(),
  type: RevisionContentsMetadataType$inboundSchema,
  version: z.string(),
  workspace_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "contains_code_samples": "containsCodeSamples",
    "created_at": "createdAt",
    "num_overlay_actions": "numOverlayActions",
    "operation_ids": "operationIds",
    "relative_diff": "relativeDiff",
    "revision_digest": "revisionDigest",
    "workspace_id": "workspaceId",
  });
});

/** @internal */
export type RevisionContentsMetadata$Outbound = {
  contains_code_samples: boolean;
  created_at: string;
  description: string;
  hash: string;
  namespace: string;
  num_overlay_actions: number;
  operation_ids: Array<string>;
  relative_diff?: RelativeDiff$Outbound | undefined;
  revision_digest: string;
  tags: Array<string>;
  title: string;
  type: string;
  version: string;
  workspace_id: string;
};

/** @internal */
export const RevisionContentsMetadata$outboundSchema: z.ZodType<
  RevisionContentsMetadata$Outbound,
  z.ZodTypeDef,
  RevisionContentsMetadata
> = z.object({
  containsCodeSamples: z.boolean(),
  createdAt: z.date().transform(v => v.toISOString()),
  description: z.string(),
  hash: z.string(),
  namespace: z.string(),
  numOverlayActions: z.number().int(),
  operationIds: z.array(z.string()),
  relativeDiff: RelativeDiff$outboundSchema.optional(),
  revisionDigest: z.string(),
  tags: z.array(z.string()),
  title: z.string(),
  type: RevisionContentsMetadataType$outboundSchema,
  version: z.string(),
  workspaceId: z.string(),
}).transform((v) => {
  return remap$(v, {
    containsCodeSamples: "contains_code_samples",
    createdAt: "created_at",
    numOverlayActions: "num_overlay_actions",
    operationIds: "operation_ids",
    relativeDiff: "relative_diff",
    revisionDigest: "revision_digest",
    workspaceId: "workspace_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RevisionContentsMetadata$ {
  /** @deprecated use `RevisionContentsMetadata$inboundSchema` instead. */
  export const inboundSchema = RevisionContentsMetadata$inboundSchema;
  /** @deprecated use `RevisionContentsMetadata$outboundSchema` instead. */
  export const outboundSchema = RevisionContentsMetadata$outboundSchema;
  /** @deprecated use `RevisionContentsMetadata$Outbound` instead. */
  export type Outbound = RevisionContentsMetadata$Outbound;
}

export function revisionContentsMetadataToJSON(
  revisionContentsMetadata: RevisionContentsMetadata,
): string {
  return JSON.stringify(
    RevisionContentsMetadata$outboundSchema.parse(revisionContentsMetadata),
  );
}

export function revisionContentsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<RevisionContentsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RevisionContentsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RevisionContentsMetadata' from JSON`,
  );
}
